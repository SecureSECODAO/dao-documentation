# What is a diamond
Diamond is the more user friendly name for [ERC-2535](https://eips.ethereum.org/EIPS/eip-2535) and it is an extension of a well known solidity pattern called proxies. Diamonds are a way of writing smart contracts, with one contract (the diamond) at its heart. This diamond does not contain any code except the ability to call code of other contracts. This makes the contract effectively infinitely flexible and upgradable. Before diving deeping into Diamonds, you will first have to understand proxies.

## What is a proxy
Proxies are a way to split the data and logic of a contract. In classical software it can be compared to MVC (model-view-controller). We have the data which is just a collection of variables with their current values and the logic which is only the functions which can update variables given their current values. This split allows us to change the logic of the contract, while keeping all variable values unchanged.

## What are proxies used for
As you know, the data on the blockchain is immutable. As smart contracts store their code on the blockchain, this means it is also immutable. Sometimes however there is a need to update contracts after their initial deployment, for example when bugs are found. In case this functionality is wanted, people can deploy a proxy. This means they deploy a data contract, which also has one variable that points to the logic contract. In case function calls are made on this storage contract, it forwards them to the logic contract instead. It does this with a [delegatecall](https://docs.soliditylang.org/en/v0.4.21/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries) instead of a normal call, which means it does not execute the code on the logic contract, but instead retrieves the code and executes it in the data contract itself. This means that the variable references in the logic contract will read the value of the same variable in the data contract instead and updates to these variables are also made in the data contract. 
In case the logic needs to be updates, a new logic contract can be deployed and the owner of the proxy can change the variable of the logic contract pointer to the newly deployed logic contract. This way all variable values are retained and all new calls made to the contract use the new logic.

## What makes diamonds different from proxies
Diamonds are so called "Multi-Facet Proxies", because the biggest differences compared to normal proxies are the fact that they dont have a single logic contract, but up to almost infinitely many. For each logic contract the diamond also specifies which function of this contract will be callable on the diamond, this way you can also partially copy the functionality of a contract. This allows the diamond to be a collection of single-purpose logic contracts and this also allows a lot more reusability of these contracts. A single logic contract of a diamond is called a facet, this is a real world diamond term for one face of a diamond.

## Diamond storage
Diamonds also implement other proxy changes, such as [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967). This allows the variable defenitions to also be defined in seperate contracts. Normally in proxies the order of the variables in the data contract and logic contract have to be the same. Otherwise they will be stored in different storage slots, starting from 0 by the solidity compiler. Having a different order of variables means these slots will contain different variables and the contract will not work as expected. Diamond storage on the other hand assigns a slot to a variable manually, based on the hash of the description. This means the variable will always be in the slot you expect it to and variables will not end up in the same slot. Unfortunately this does mean that you can only use this way of storage, as using normal variables will put every first variable of each logic contract at slot 0, which means they will collide. This has the disadvantage of having to rewrite existing contract you want to include in your diamond as facets with diamond storage. This convertation however is quite easy and could likely even be automated in the future.

## Diamond cut and loupe
For changing the diamond there are two required components. Firstly we have the diamond cut, which allows changing the diamonds logic contracts. It can be used to add, replace or remove methods of logic contracts and in this sense update or upgrade the diamond. To make changes to the diamond however, you might want to know what the current configuration of the diamond looks like. This is where the diamond loupe comes into play. It contains functions to inspect the diamond, see what methods are available and what contract they currently point to. Both terms originate from the real world diamond business. A famous diamond inspector website, which can also be used for cutting diamonds, is https://louper.dev/. It is made by the proposer of the diamond standard: Nick Mudge.
